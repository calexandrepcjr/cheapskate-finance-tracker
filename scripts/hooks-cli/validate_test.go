package main

import (
	"os"
	"path/filepath"
	"testing"
)

func TestValidateCommitMessage(t *testing.T) {
	tests := []struct {
		name    string
		message string
		wantErr bool
	}{
		// Valid conventional commits
		{
			name:    "feat without scope",
			message: "feat: add new feature",
			wantErr: false,
		},
		{
			name:    "fix with scope",
			message: "fix(parser): handle edge case",
			wantErr: false,
		},
		{
			name:    "docs without scope",
			message: "docs: update README",
			wantErr: false,
		},
		{
			name:    "style without scope",
			message: "style: fix indentation",
			wantErr: false,
		},
		{
			name:    "refactor with scope",
			message: "refactor(handlers): extract common logic",
			wantErr: false,
		},
		{
			name:    "perf without scope",
			message: "perf: optimize database queries",
			wantErr: false,
		},
		{
			name:    "test with scope",
			message: "test(db): add integration tests",
			wantErr: false,
		},
		{
			name:    "build without scope",
			message: "build: upgrade Go version",
			wantErr: false,
		},
		{
			name:    "ci without scope",
			message: "ci: add GitHub Actions workflow",
			wantErr: false,
		},
		{
			name:    "chore without scope",
			message: "chore: update .gitignore",
			wantErr: false,
		},
		{
			name:    "revert without scope",
			message: "revert: revert previous commit",
			wantErr: false,
		},
		{
			name:    "scope with hyphen",
			message: "feat(user-auth): add login",
			wantErr: false,
		},
		{
			name:    "scope with underscore",
			message: "fix(db_queries): fix null handling",
			wantErr: false,
		},
		{
			name:    "scope with numbers",
			message: "feat(api2): add v2 endpoints",
			wantErr: false,
		},
		{
			name:    "multiline message",
			message: "feat: add new feature\n\nThis is a longer description.",
			wantErr: false,
		},

		// Special cases that should pass
		{
			name:    "merge commit",
			message: "Merge pull request #123 from branch",
			wantErr: false,
		},
		{
			name:    "merge branch",
			message: "Merge branch 'main' into feature",
			wantErr: false,
		},
		{
			name:    "revert commit generated by git",
			message: `Revert "feat: add feature"`,
			wantErr: false,
		},

		// Invalid commits
		{
			name:    "missing type",
			message: "add new feature",
			wantErr: true,
		},
		{
			name:    "uppercase type",
			message: "FEAT: add new feature",
			wantErr: true,
		},
		{
			name:    "mixed case type",
			message: "Feat: add new feature",
			wantErr: true,
		},
		{
			name:    "wrong separator - hyphen",
			message: "feat - add new feature",
			wantErr: true,
		},
		{
			name:    "missing space after colon",
			message: "feat:add new feature",
			wantErr: true,
		},
		{
			name:    "empty description",
			message: "feat: ",
			wantErr: true,
		},
		{
			name:    "invalid type",
			message: "feature: add something",
			wantErr: true,
		},
		{
			name:    "empty message",
			message: "",
			wantErr: true,
		},
		{
			name:    "whitespace only",
			message: "   ",
			wantErr: true,
		},
		{
			name:    "uppercase scope",
			message: "feat(Parser): add feature",
			wantErr: true,
		},
		{
			name:    "scope with space",
			message: "feat(my scope): add feature",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateCommitMessage(tt.message)
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidateCommitMessage(%q) error = %v, wantErr %v", tt.message, err, tt.wantErr)
			}
		})
	}
}

func TestValidateCommitMessageFile(t *testing.T) {
	// Create a temporary directory for test files
	tmpDir, err := os.MkdirTemp("", "hooks-cli-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	tests := []struct {
		name    string
		content string
		wantErr bool
	}{
		{
			name:    "valid commit message",
			content: "feat: add new feature\n",
			wantErr: false,
		},
		{
			name:    "valid with comments",
			content: "feat: add new feature\n# This is a comment\n# Another comment\n",
			wantErr: false,
		},
		{
			name:    "invalid commit message",
			content: "add new feature\n",
			wantErr: true,
		},
		{
			name:    "multiline with body",
			content: "fix(parser): handle edge case\n\nThis fixes the bug where...\n# Comment\n",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temp file with content
			filePath := filepath.Join(tmpDir, "COMMIT_EDITMSG")
			if err := os.WriteFile(filePath, []byte(tt.content), 0644); err != nil {
				t.Fatalf("Failed to write test file: %v", err)
			}

			err := ValidateCommitMessageFile(filePath)
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidateCommitMessageFile() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestValidateCommitMessageFile_NonExistent(t *testing.T) {
	err := ValidateCommitMessageFile("/nonexistent/file/path")
	if err == nil {
		t.Error("ValidateCommitMessageFile() should return error for non-existent file")
	}
}

func TestIsValidCommitType(t *testing.T) {
	validTypes := []string{"feat", "fix", "docs", "style", "refactor", "perf", "test", "build", "ci", "chore", "revert"}
	invalidTypes := []string{"feature", "bugfix", "doc", "FEAT", "Fix", "random", ""}

	for _, typ := range validTypes {
		if !IsValidCommitType(typ) {
			t.Errorf("IsValidCommitType(%q) = false, want true", typ)
		}
	}

	for _, typ := range invalidTypes {
		if IsValidCommitType(typ) {
			t.Errorf("IsValidCommitType(%q) = true, want false", typ)
		}
	}
}

func TestValidationError_Error(t *testing.T) {
	err := &ValidationError{
		Message:   "test error",
		FirstLine: "bad commit message",
	}

	errStr := err.Error()

	// Check that error message contains key information
	if !contains(errStr, "COMMIT REJECTED") {
		t.Error("Error message should contain 'COMMIT REJECTED'")
	}
	if !contains(errStr, "bad commit message") {
		t.Error("Error message should contain the commit message")
	}
	if !contains(errStr, "feat") {
		t.Error("Error message should list valid types")
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsHelper(s, substr))
}

func containsHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
